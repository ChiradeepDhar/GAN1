# -*- coding: utf-8 -*-
"""GAN.1ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1FdnGFvIukOapdya1LzDSMxAIkYQj3IuM
"""

import os
import logging
import numpy as np
import pandas as pd
import tensorflow as tf

data = pd.read_csv('/content/Parkinsson disease.csv')
data.head()
data=data.drop('name',axis=1)

data.head()

class Gan():

    def __init__(self, data):


        self.data = data
        self.n_epochs = 500


    def _noise(self):
        noise = np.random.normal(0, 1, self.data.shape)
        return noise

    def _generator(self):
        model = tf.keras.Sequential(name="Generator_model")
        model.add(tf.keras.layers.Dense(15, activation='relu',
                                        kernel_initializer='he_uniform',
                                        input_dim=self.data.shape[1]))
        model.add(tf.keras.layers.Dense(30, activation='relu'))
        model.add(tf.keras.layers.Dense(
            self.data.shape[1], activation='linear'))
        return model

    def _discriminator(self):
        model = tf.keras.Sequential(name="Discriminator_model")
        model.add(tf.keras.layers.Dense(25, activation='relu',
                                        kernel_initializer='he_uniform',
                                        input_dim=self.data.shape[1]))
        model.add(tf.keras.layers.Dense(50, activation='relu'))

        model.add(tf.keras.layers.Dense(1, activation='sigmoid'))
        model.compile(loss='binary_crossentropy',
                      optimizer='adam',
                      metrics=['accuracy'])

        return model


    def _GAN(self, generator, discriminator):
        discriminator.trainable = False
        generator.trainable = True
        model = tf.keras.Sequential(name="GAN")
        model.add(generator)
        model.add(discriminator)
        model.compile(loss='binary_crossentropy', optimizer='adam')
        return model


    def train(self, generator, discriminator, gan):

        for epoch in range(self.n_epochs):

            generated_data = generator.predict(self._noise())
            labels = np.concatenate([np.ones(self.data.shape[0]), np.zeros(self.data.shape[0])])
            X = np.concatenate([self.data, generated_data])
            discriminator.trainable = True
            d_loss , _ = discriminator.train_on_batch(X, labels)

            noise = self._noise()
            g_loss = gan.train_on_batch(noise, np.ones(self.data.shape[0]))


            print('>%d, d1=%.3f, d2=%.3f' %(epoch+1, d_loss, g_loss))

        return generator

model = Gan(data=data)
generator = model._generator()
descriminator = model._discriminator()
gan_model = model._GAN(generator=generator, discriminator=descriminator)
trained_model = model.train(generator=generator, discriminator=descriminator, gan=gan_model)

def _df(data):
    df = pd.DataFrame(data)
    for c in range(df.shape[1]):
        mapping = {df.columns[c]: c}
        df = df.rename(columns=mapping)
    return df

noise = np.random.normal(0, 1, data.shape)
new_data = _df(data=trained_model.predict(noise))

new_data

from sklearn.preprocessing import StandardScaler
df = pd.read_csv('/content/Parkinsson disease.csv')
df.drop(columns=['name'],inplace=True)
scaler = StandardScaler()
scaler.fit(df)

new_data_inverse = scaler.inverse_transform(new_data)

new_data_df = pd.DataFrame(new_data_inverse, columns=df.columns)

new_data_df

new_data_df.status.describe()

import matplotlib.pyplot as plt
plt.hist(data.status)

plt.hist(new_data_df.status)

